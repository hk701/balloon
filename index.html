<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AR çº¢è‰²æ°”çƒ - é™€èºä»ªç‰ˆ</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
    }
    canvas {
      display: block;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      background: rgba(0,0,0,0.5);
      padding: 10px;
      border-radius: 5px;
      font-size: 14px;
      z-index: 100;
    }
    #permission-btn {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 20px 40px;
      font-size: 18px;
      background: #ff0000;
      color: white;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      z-index: 200;
    }
  </style>
</head>
<body>
  <div id="info">å¯¹ç€éº¦å…‹é£è¯´è¯é‡Šæ”¾çº¢è‰²æ°”çƒ ğŸˆ</div>
  <button id="permission-btn" style="display: none;">ç‚¹å‡»å¯åŠ¨ AR8 ä½“éªŒ</button>
  
  <script type="module">
    import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js';

    let scene, camera, renderer;
    let balloons = [];
    let video, videoTexture;
    let analyser, audioData;
    let audioContext;
    let isAudioReady = false;
    
    // ========== å…¨å±€å¯è°ƒå‚æ•° ==========
    const MAX_BALLOONS = 60;        // æœ€å¤§æ°”çƒæ•°é‡
    const AUDIO_THRESHOLD = 5;     // å£°éŸ³è§¦å‘é˜ˆå€¼
    const AUDIO_COOLDOWN = 100;     // å£°éŸ³è§¦å‘å†·å´æ—¶é—´(ms)
    // ==================================
    
    // é™€èºä»ªç›¸å…³å˜é‡
    let deviceOrientation = { alpha: 0, beta: 0, gamma: 0 };
    let initialOrientation = null;
    let hasGyroscope = false;
    let calibrationFrames = 0;
    let currentRotationY = 0;  // å½“å‰å®é™…çš„Yè½´æ—‹è½¬
    let lastUpdateTime = Date.now();  // ä¸Šæ¬¡æ›´æ–°æ—¶é—´
    
    // ä¸–ç•Œç©ºé—´å®¹å™¨ï¼ˆç”¨äºå›ºå®šæ°”çƒåœ¨ä¸–ç•Œåæ ‡ä¸­ï¼‰
    let worldContainer;

    init();
    animate();

    function init() {
      // åˆ›å»ºåœºæ™¯
      scene = new THREE.Scene();
      
      // åˆ›å»ºç›¸æœºï¼ˆå¢å¤§FOVä»¥è·å¾—æ›´å¥½çš„ARæ•ˆæœï¼‰
      camera = new THREE.PerspectiveCamera(
        80, 
        window.innerWidth / window.innerHeight, 
        0.1, 
        1000
      );
      camera.position.set(0, 0, 0);

      // åˆ›å»ºæ¸²æŸ“å™¨
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      document.body.appendChild(renderer.domElement);

      // åˆ›å»ºä¸–ç•Œå®¹å™¨ï¼ˆæ‰€æœ‰æ°”çƒéƒ½æ·»åŠ åˆ°è¿™ä¸ªå®¹å™¨ä¸­ï¼‰
      worldContainer = new THREE.Group();
      scene.add(worldContainer);

      // æ·»åŠ å…‰ç…§
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(5, 5, 5);
      scene.add(directionalLight);
      
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      // æ£€æŸ¥è®¾å¤‡æ–¹å‘æƒé™ï¼ˆiOS 13+éœ€è¦ï¼‰
      if (typeof DeviceOrientationEvent !== 'undefined' && 
          typeof DeviceOrientationEvent.requestPermission === 'function') {
        // iOS 13+ éœ€è¦ç”¨æˆ·äº¤äº’
        document.getElementById('permission-btn').style.display = 'block';
        document.getElementById('permission-btn').onclick = requestPermissions;
      } else {
        // å…¶ä»–è®¾å¤‡ç›´æ¥åˆå§‹åŒ–
        initDeviceOrientation();
        initCameraAndAudio();
      }

      // çª—å£å¤§å°è°ƒæ•´
      window.addEventListener('resize', onWindowResize);
    }

    async function requestPermissions() {
      try {
        // è¯·æ±‚é™€èºä»ªæƒé™
        const response = await DeviceOrientationEvent.requestPermission();
        if (response === 'granted') {
          initDeviceOrientation();
        }
        
        // éšè—æŒ‰é’®
        document.getElementById('permission-btn').style.display = 'none';
        
        // åˆå§‹åŒ–æ‘„åƒå¤´å’ŒéŸ³é¢‘
        await initCameraAndAudio();
      } catch (error) {
        console.error('æƒé™è¯·æ±‚å¤±è´¥:', error);
        alert('éœ€è¦é™€èºä»ªæƒé™æ‰èƒ½è·å¾—æœ€ä½³ä½“éªŒ');
      }
    }

    function initDeviceOrientation() {
      // ç›‘å¬è®¾å¤‡æ–¹å‘å˜åŒ–
      window.addEventListener('deviceorientation', handleOrientation);
      
      // æ£€æµ‹æ˜¯å¦æœ‰é™€èºä»ª
      setTimeout(() => {
        if (deviceOrientation.alpha === 0 && 
            deviceOrientation.beta === 0 && 
            deviceOrientation.gamma === 0) {
          console.log('è®¾å¤‡å¯èƒ½ä¸æ”¯æŒé™€èºä»ª');
          hasGyroscope = false;
        } else {
          hasGyroscope = true;
          console.log('é™€èºä»ªå·²å¯ç”¨');
        }
      }, 1000);
    }

    function handleOrientation(event) {
      if (event.alpha !== null && event.beta !== null && event.gamma !== null) {
        deviceOrientation = {
          alpha: event.alpha,
          beta: event.beta,
          gamma: event.gamma
        };
        
        // è®°å½•åˆå§‹æ–¹å‘ï¼ˆç­‰å¾…å‡ å¸§ä»¥è·å¾—ç¨³å®šå€¼ï¼‰
        if (!initialOrientation && calibrationFrames++ > 10) {
          initialOrientation = { ...deviceOrientation };
          console.log('åˆå§‹æ–¹å‘å·²æ ¡å‡†');
        }
        
        hasGyroscope = true;
      }
    }

    function updateCameraRotation() {
      if (!hasGyroscope || !initialOrientation) return;
      
      // ========== å¯è°ƒå‚æ•° ==========
      const smoothingFactor = 0.1;      // åŸºç¡€å¹³æ»‘åº¦
      const maxRotationSpeed = 2;       // æœ€å¤§æ—‹è½¬é€Ÿåº¦ï¼ˆåº¦/å¸§ï¼‰
      const verticalDamping = 5;        // ç«–ç›´æ—¶çš„é˜»å°¼ç³»æ•°
      // ==============================
      
      // è·å–å½“å‰æ—¶é—´
      const currentTime = Date.now();
      const deltaTime = Math.min((currentTime - lastUpdateTime) / 16.67, 2); // å½’ä¸€åŒ–åˆ°60fps
      lastUpdateTime = currentTime;
      
      // è·å–å½“å‰è§’åº¦
      const beta = deviceOrientation.beta;
      const alpha = deviceOrientation.alpha;
      
      // è®¡ç®—ç›®æ ‡æ—‹è½¬
      let deltaAlpha = alpha - initialOrientation.alpha;
      
      // å¤„ç†360åº¦è¾¹ç•Œ
      if (deltaAlpha > 180) deltaAlpha -= 360;
      if (deltaAlpha < -180) deltaAlpha += 360;
      
      // è½¬æ¢ä¸ºå¼§åº¦
      const targetRotationY = -THREE.MathUtils.degToRad(deltaAlpha);
      
      // è®¡ç®—ä¸å½“å‰æ—‹è½¬çš„å·®å¼‚
      let rotationDiff = targetRotationY - currentRotationY;
      
      // ç¡®ä¿å·®å¼‚åœ¨-PIåˆ°PIä¹‹é—´
      if (rotationDiff > Math.PI) rotationDiff -= Math.PI * 2;
      if (rotationDiff < -Math.PI) rotationDiff += Math.PI * 2;
      
      // è®¡ç®—ç«–ç›´ç¨‹åº¦ï¼ˆ0-1ï¼Œ1è¡¨ç¤ºå®Œå…¨ç«–ç›´ï¼‰
      const verticalness = Math.abs(beta - 90) < 30 ? 1 - Math.abs(beta - 90) / 30 : 0;
      
      // æ ¹æ®ç«–ç›´ç¨‹åº¦è°ƒæ•´å¹³æ»‘å› å­å’Œé€Ÿåº¦é™åˆ¶
      const adaptiveSmoothing = smoothingFactor * (1 - verticalness * 0.9); // è¶Šç«–ç›´è¶Šæ…¢
      const adaptiveSpeedLimit = maxRotationSpeed * (1 - verticalness * 0.8); // è¶Šç«–ç›´é€Ÿåº¦è¶Šæ…¢
      
      // é™åˆ¶æ—‹è½¬é€Ÿåº¦
      const maxRotationRad = THREE.MathUtils.degToRad(adaptiveSpeedLimit * deltaTime);
      rotationDiff = THREE.MathUtils.clamp(rotationDiff, -maxRotationRad, maxRotationRad);
      
      // åº”ç”¨é¢å¤–çš„é˜»å°¼
      if (verticalness > 0) {
        rotationDiff *= (1 - verticalness * 0.5);
      }
      
      // åº”ç”¨æ—‹è½¬
      currentRotationY += rotationDiff * adaptiveSmoothing;
      
      // ç¡®ä¿æ—‹è½¬å€¼åœ¨åˆç†èŒƒå›´å†…
      if (currentRotationY > Math.PI) currentRotationY -= Math.PI * 2;
      if (currentRotationY < -Math.PI) currentRotationY += Math.PI * 2;
      
      // æ›´æ–°ä¸–ç•Œå®¹å™¨
      worldContainer.rotation.y = currentRotationY;
      worldContainer.rotation.x = 0;
      worldContainer.rotation.z = 0;
    }

    async function initCameraAndAudio() {
      try {
        // åˆ†åˆ«è¯·æ±‚è§†é¢‘å’ŒéŸ³é¢‘
        const videoStream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: 'environment',
            width: { ideal: 1920 },
            height: { ideal: 1080 }
          },
          audio: false
        });

        // è®¾ç½®è§†é¢‘æµ
        video = document.createElement('video');
        video.srcObject = videoStream;
        video.setAttribute('playsinline', '');
        video.setAttribute('muted', '');
        video.muted = true;
        video.play();

        video.onloadedmetadata = () => {
          videoTexture = new THREE.VideoTexture(video);
          videoTexture.minFilter = THREE.LinearFilter;
          videoTexture.magFilter = THREE.LinearFilter;
          scene.background = videoTexture;
        };

        // å•ç‹¬è·å–éŸ³é¢‘æµ
        const audioStream = await navigator.mediaDevices.getUserMedia({
          video: false,
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true
          }
        });

        setupAudio(audioStream);
        
      } catch (error) {
        console.error('æ— æ³•è®¿é—®æ‘„åƒå¤´æˆ–éº¦å…‹é£:', error);
        document.getElementById('info').textContent = 'è¯·å…è®¸æ‘„åƒå¤´å’Œéº¦å…‹é£æƒé™';
        scene.background = new THREE.Color(0x87CEEB);
      }
    }

    function setupAudio(stream) {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      
      const source = audioContext.createMediaStreamSource(stream);
      
      analyser = audioContext.createAnalyser();
      analyser.fftSize = 256;
      analyser.smoothingTimeConstant = 0.3;
      
      source.connect(analyser);
      
      audioData = new Uint8Array(analyser.frequencyBinCount);
      
      isAudioReady = true;
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function createBalloon() {
      // åœ¨ä¸–ç•Œç©ºé—´ä¸­éšæœºä½ç½®ï¼ˆç›¸å¯¹äºå½“å‰è§†è§’ï¼‰
      const distance = 5 + Math.random() * 10; // 5-15ç±³è¿œ
      const angleH = (Math.random() - 0.5) * Math.PI * 0.8; // æ›´å®½çš„æ°´å¹³è§’åº¦
      const angleV = (Math.random() - 0.5) * Math.PI * 0.4; // æ›´å®½çš„å‚ç›´è§’åº¦
      
      // è®¡ç®—ä¸–ç•Œåæ ‡ä½ç½®
      const x = distance * Math.sin(angleH) * Math.cos(angleV);
      const y = -3 + Math.random() * 2 + distance * Math.sin(angleV) * 0.3; // ä»æ›´ä½å¤„å¼€å§‹ï¼Œè€ƒè™‘å‚ç›´è§’åº¦
      const z = -distance * Math.cos(angleH) * Math.cos(angleV);
      
      const scale = 0.4 + Math.random() * 1.2; // æ›´å¤šå¤§å°å˜åŒ–
      
      // æ£€æŸ¥é‡å 
      let overlapping = false;
      for (const balloon of balloons) {
        const distance = balloon.position.distanceTo(new THREE.Vector3(x, y, z));
        if (distance < scale + balloon.userData.scale) {
          overlapping = true;
          break;
        }
      }
      
      if (overlapping) return;
      
      // åˆ›å»ºæ°”çƒç»„
      const balloonGroup = new THREE.Group();
      
      // æ°”çƒä¸»ä½“
      const balloonGeometry = new THREE.SphereGeometry(0.5, 32, 16);
      const balloonMaterial = new THREE.MeshPhongMaterial({
        color: 0xff0000,
        shininess: 5,  // å¤§å¹…é™ä½å…‰æ³½åº¦ï¼ˆåŸæ¥æ˜¯100ï¼‰
        specular: 0x220000  // æš—çº¢è‰²é«˜å…‰ï¼Œæ›´å“‘å…‰çš„æ•ˆæœ
      });
      const balloonMesh = new THREE.Mesh(balloonGeometry, balloonMaterial);
      balloonMesh.scale.y = 1.2;
      balloonGroup.add(balloonMesh);
      
      // ç»³å­
      const ropeGeometry = new THREE.CylinderGeometry(0.003, 0.003, 1.2, 4); // æ›´ç»†çš„ç»³å­
      const ropeMaterial = new THREE.MeshBasicMaterial({ 
        color: 0x666666,  // æ›´æµ…çš„ç°è‰²
        transparent: true,
        opacity: 0.5  // åŠé€æ˜
      });
      const ropeMesh = new THREE.Mesh(ropeGeometry, ropeMaterial);
      ropeMesh.position.y = -1;
      balloonGroup.add(ropeMesh);
      
      // è®¾ç½®åœ¨ä¸–ç•Œç©ºé—´ä¸­çš„ä½ç½®
      balloonGroup.position.set(x, y, z);
      balloonGroup.scale.set(scale, scale, scale);
      
      // ä¿å­˜åˆå§‹ä¸–ç•Œä½ç½®ï¼Œç”¨äºç‰©ç†æ¨¡æ‹Ÿ
      balloonGroup.userData = {
        speed: 0.008 + Math.random() * 0.015, // ç¨æ…¢çš„ä¸Šå‡é€Ÿåº¦
        swaySpeed: 0.5 + Math.random() * 1.5, // æ›´è‡ªç„¶çš„æ‘‡æ‘†é€Ÿåº¦
        swayAmount: 0.15 + Math.random() * 0.3, // å¢åŠ æ‘‡æ‘†å¹…åº¦
        scale: scale,
        worldPosition: new THREE.Vector3(x, y, z),
        initialY: y,
        windPhase: Math.random() * Math.PI * 2, // éšæœºé£ç›¸ä½
        rotationSpeed: (Math.random() - 0.5) * 0.5 // éšæœºæ—‹è½¬é€Ÿåº¦
      };
      
      // æ·»åŠ åˆ°ä¸–ç•Œå®¹å™¨è€Œä¸æ˜¯åœºæ™¯
      worldContainer.add(balloonGroup);
      balloons.push(balloonGroup);
    }

    function updateBalloons() {
      const time = Date.now() * 0.001;
      
      for (let i = balloons.length - 1; i >= 0; i--) {
        const balloon = balloons[i];
        
        // åœ¨ä¸–ç•Œç©ºé—´ä¸­ä¸Šå‡ï¼ˆå¸¦è½»å¾®åŠ é€Ÿï¼‰
        balloon.userData.speed *= 1.001; // è½»å¾®åŠ é€Ÿæ•ˆæœ
        balloon.userData.worldPosition.y += balloon.userData.speed;
        
        // æ›´è‡ªç„¶çš„æ‘‡æ‘†ï¼ˆç»“åˆå¤šä¸ªæ­£å¼¦æ³¢ï¼‰
        const windEffect = Math.sin(time * 0.3 + balloon.userData.windPhase) * 0.5 + 0.5;
        const swayX = Math.sin(time * balloon.userData.swaySpeed + balloon.userData.windPhase) * 
                     balloon.userData.swayAmount * (1 + windEffect);
        const swayZ = Math.cos(time * balloon.userData.swaySpeed * 0.7 + balloon.userData.windPhase) * 
                     balloon.userData.swayAmount * 0.6 * (1 + windEffect);
        
        // é«˜åº¦å½±å“æ‘‡æ‘†ï¼ˆè¶Šé«˜æ‘‡æ‘†è¶Šå¤§ï¼‰
        const heightFactor = 1 + (balloon.userData.worldPosition.y - balloon.userData.initialY) * 0.05;
        
        // æ›´æ–°æ°”çƒä½ç½®
        balloon.position.set(
          balloon.userData.worldPosition.x + swayX * heightFactor,
          balloon.userData.worldPosition.y,
          balloon.userData.worldPosition.z + swayZ * heightFactor
        );
        
        // æ›´è‡ªç„¶çš„æ—‹è½¬
        balloon.rotation.z = Math.sin(time * balloon.userData.swaySpeed * 0.8) * 0.15;
        balloon.rotation.x = Math.cos(time * balloon.userData.swaySpeed * 0.6) * 0.1;
        balloon.rotation.y += balloon.userData.rotationSpeed * 0.01;
        
        // ç§»é™¤é£å¾—å¤ªé«˜çš„æ°”çƒ
        if (balloon.userData.worldPosition.y > 20) {
          worldContainer.remove(balloon);
          balloons.splice(i, 1);
        }
      }
    }

    function checkAudioLevel() {
      if (!isAudioReady || !analyser) return;
      
      analyser.getByteFrequencyData(audioData);
      
      let sum = 0;
      for (let i = 0; i < audioData.length; i++) {
        sum += audioData[i];
      }
      const average = sum / audioData.length;
      
      if (average > AUDIO_THRESHOLD && balloons.length < MAX_BALLOONS) {
        createBalloon();
        
        // æ›´çŸ­çš„å†·å´æ—¶é—´ï¼Œæ›´çµæ•
        isAudioReady = false;
        setTimeout(() => {
          isAudioReady = true;
        }, AUDIO_COOLDOWN);
      }
    }

    function animate() {
      requestAnimationFrame(animate);
      
      // æ›´æ–°ç›¸æœºæ—‹è½¬ï¼ˆåŸºäºé™€èºä»ªï¼‰
      updateCameraRotation();
      
      // æ£€æŸ¥éŸ³é¢‘è§¦å‘
      checkAudioLevel();
      
      // æ›´æ–°æ°”çƒ
      updateBalloons();
      
      // æ¸²æŸ“åœºæ™¯
      renderer.render(scene, camera);
    }

    // ç‚¹å‡»å¤‡ç”¨è§¦å‘
    document.addEventListener('click', (e) => {
      // é¿å…ç‚¹å‡»æŒ‰é’®æ—¶è§¦å‘
      if (e.target.id !== 'permission-btn' && balloons.length < MAX_BALLOONS) {
        createBalloon();
      }
    });
  </script>
</body>
</html>
